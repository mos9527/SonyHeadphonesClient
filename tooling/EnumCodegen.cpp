#include <clang-c/Index.h>
#include <fmt/base.h>
#include <string>
using namespace fmt;
// Q: Why are these globals?
// A: We don't need to capture these in lambdas.
std::string gSrc = "libmdr/ProtocolV2T1Enums.hpp";
std::string gNamespaceName = "mdr::v2::t1";

std::string getFullParentName(CXCursor c)
{
    std::string s;
    while (true)
    {
        CXString name = clang_getCursorSpelling(c);
        std::string nameStr = clang_getCString(name);
        clang_disposeString(name);
        if (nameStr.empty())
            break;
        if (clang_getCursorKind(c) != CXCursor_TranslationUnit)
            s = nameStr + (s.empty() ? "" : "::") + s;
        c = clang_getCursorSemanticParent(c);
        if (clang_equalCursors(c, clang_getNullCursor()))
            break;
    }
    return s;
}

std::string gPrevDeclName;
CXCursorVisitor gEnumIn, gEnumVisit, gEnumOut;
CXChildVisitResult visitor(CXCursor c, CXCursor parent, CXClientData)
{
    CXCursorKind kind = clang_getCursorKind(c);
    switch (kind)
    {
    case CXCursor_Namespace:
        return CXChildVisit_Recurse;
    case CXCursor_EnumDecl:
    {
        std::string parentStr = getFullParentName(parent);
        if (parentStr != gNamespaceName)
            return CXChildVisit_Continue;
        CXString name = clang_getCursorSpelling(c);
        if (!gPrevDeclName.empty() && gPrevDeclName != clang_getCString(name))
            gEnumOut(c, parent, nullptr);
        gEnumIn(c, parent, nullptr);
        clang_visitChildren(
            c,
            gEnumVisit,
            nullptr);
        gPrevDeclName = clang_getCString(name);
        clang_disposeString(name);
        return CXChildVisit_Continue;
    }
    default:
        return CXChildVisit_Continue;
    }
}
CXChildVisitResult enumNameIn(CXCursor c, CXCursor, CXClientData)
{
    CXString name = clang_getCursorSpelling(c);
    println("    static const char* format_as({} value) {{", clang_getCString(name));
    println("        using enum {};", clang_getCString(name));
    println("        switch (value) {{");
    clang_disposeString(name);
    return CXChildVisit_Continue;
}
CXChildVisitResult enumNameVisit(CXCursor c, CXCursor, CXClientData)
{
    CXString enumName = clang_getCursorDisplayName(c);
    println("            case {}: return \"{}\";", clang_getCString(enumName), clang_getCString(enumName));
    clang_disposeString(enumName);
    return CXChildVisit_Continue;
}
CXChildVisitResult enumNameOut(CXCursor, CXCursor, CXClientData)
{
    println("            default: return \"Unknown\";");
    println("        }}");
    println("    }}");
    return CXChildVisit_Continue;
}
CXChildVisitResult enumRangeIn(CXCursor c, CXCursor, CXClientData)
{
    CXString name = clang_getCursorSpelling(c);
    println("    static bool is_valid({} value) {{", clang_getCString(name));
    println("        using enum {};", clang_getCString(name));
    println("        switch (value) {{");
    clang_disposeString(name);
    return CXChildVisit_Continue;
}
CXChildVisitResult enumRangeVisit(CXCursor c, CXCursor, CXClientData)
{
    CXString enumName = clang_getCursorDisplayName(c);
    println("            case {}:", clang_getCString(enumName), clang_getCString(enumName));
    clang_disposeString(enumName);
    return CXChildVisit_Continue;
}
CXChildVisitResult enumRangeOut(CXCursor, CXCursor, CXClientData)
{
    println("            return true;");
    println("        default: return false;");
    println("        }}");
    println("    }}");
    return CXChildVisit_Continue;
}
void doVisit(CXCursor cursor, CXCursorVisitor in, CXCursorVisitor visit, CXCursorVisitor out)
{
    gEnumVisit = visit, gEnumIn = in, gEnumOut = out;
    gPrevDeclName.clear();
    clang_visitChildren(cursor, visitor, nullptr);
    out(cursor, cursor, nullptr);
}
int main( int argc, char** argv )
{
    if (argc != 3)
    {
        println("usage: {} <source-file> <namespace-name>", argv[0]);
        println("\tGenerate enum codegen for the given source file and namespace name.");
        println("\tOutput is printed to stdout.");
        return 1;
    }
    gSrc = argv[1];
    gNamespaceName = argv[2];
    CXIndex index = clang_createIndex(0, 0);
    CXTranslationUnit unit = clang_parseTranslationUnit(
        index,
        gSrc.c_str(),
        nullptr, 0,
        nullptr, 0,
        CXTranslationUnit_None);
    CXCursor cursor = clang_getTranslationUnitCursor(unit);
    println("/* This file is auto-generated by tooling/EnumCodegen.cpp */");
    println("#pragma once");
    println("");
    println("namespace {} {{", gNamespaceName);
    doVisit(cursor, enumNameIn, enumNameVisit, enumNameOut);
    doVisit(cursor, enumRangeIn, enumRangeVisit, enumRangeOut);
    println("}}");

    clang_disposeTranslationUnit(unit);
    clang_disposeIndex(index);
    return 0;
}

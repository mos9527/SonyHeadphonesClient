#include <vector>
#include <algorithm>
#include "Codegen.hpp"
const char* kMDRExternMacro = "MDR_DEFINE_EXTERN_SERIALIZATION";
const char* kMDRIgnoredMacro = "MDR_CODEGEN_IGNORE_SERIALIZATION";
const char* kMDRPrefix = "MDR";
// Q: Why are these globals?
// A: We don't need to capture these in lambdas.
std::string gSrc = "libmdr/ProtocolV2T1Enums.hpp";
std::string gNamespaceName = "mdr::v2::t1";
using MacroPair = std::pair<int, std::string>; // Line, Name
std::vector<MacroPair> gMacros;
CXChildVisitResult macroVisitor(CXCursor cursor, CXCursor parent, CXClientData)
{
    CXCursorKind kind = clang_getCursorKind(cursor);
    if (kind == CXCursor_MacroExpansion)
    {
        CXString name = clang_getCursorSpelling(cursor);
        CXSourceLocation loc = clang_getCursorLocation(cursor);
        // Identify macros with line numbers. getLexicalParent doesn't work since we're still
        // in the preprocessor
        CXFile file; unsigned line, col, offset;
        clang_getSpellingLocation(loc, &file, &line, &col, &offset);
        CXString fileName = clang_getFileName(file);
        std::string fileStr = clang_getCString(fileName);
        if (fileStr == gSrc)
            gMacros.emplace_back(line, clang_getCString(name));
        clang_disposeString(name);
        clang_disposeString(fileName);
    }
    return CXChildVisit_Continue;
}
CXChildVisitResult fieldSerializeVisitor(CXCursor cursor, CXCursor parent, CXClientData)
{
    CXCursorKind kind = clang_getCursorKind(cursor);
    if (kind == CXCursor_FieldDecl)
    {
        CXString name = clang_getCursorSpelling(cursor);
        CXType type = clang_getCursorType(cursor);
        CXString typeName = clang_getTypeSpelling(type);
        println("        Field {} ({});", clang_getCString(typeName), clang_getCString(name));
        clang_disposeString(name);
        clang_disposeString(typeName);
    }
    return CXChildVisit_Continue;
}
CXChildVisitResult structVisitor(CXCursor cursor, CXCursor parent, CXClientData)
{
    CXCursorKind kind = clang_getCursorKind(cursor);
    switch (kind)
    {
    case CXCursor_Namespace:
        return CXChildVisit_Recurse;
    case CXCursor_StructDecl:
    {
        std::string parentStr = getFullParentName(parent);
        if (parentStr != gNamespaceName)
            return CXChildVisit_Continue;
        CXString name = clang_getCursorSpelling(cursor);
        std::string structName = clang_getCString(name);
        /* Collect macros */
        auto [startLine, endLine] = getCursorExtents(cursor);
        auto start = std::ranges::lower_bound(gMacros, MacroPair{startLine,""});
        std::vector<std::string> macros;
        bool isExtern = false, isIgnored = false;
        for (auto it = start; it != gMacros.end() && it->first < endLine; ++it)
        {
            if (it->second == kMDRIgnoredMacro) isIgnored = true;
            if (it->second == kMDRExternMacro) isExtern = true;
        }
        // Emit serialization bodies
        if (isExtern && !isIgnored)
        {
            println("    size_t {}::Serialize(const {}& data, UInt8* out)", structName,structName);
            println("    {{");
            println("        UInt8* ptr = out;");
            clang_visitChildren(cursor, fieldSerializeVisitor, nullptr);
            println("        return ptr - out;");
            println("    }}");
        }
        clang_disposeString(name);
        return CXChildVisit_Continue;
    }
    default:
        return CXChildVisit_Continue;
    }
}

int main( int argc, char** argv )
{
    if (argc != 3)
    {
        println("usage: {} <source-file> <namespace-name>", argv[0]);
        println("\tGenerate MDR_DEFINE_EXTERN_SERIALIZATION bodies for the given source file and namespace name.");
        println("\tOutput is printed to stdout.");
        return 1;
    }
    gSrc = argv[1];
    gNamespaceName = argv[2];
    CXIndex index = clang_createIndex(0, 0);
    CXTranslationUnit unit = clang_parseTranslationUnit(
        index,
        gSrc.c_str(),
        nullptr, 0,
        nullptr, 0,
        CXTranslationUnit_DetailedPreprocessingRecord);
    CXCursor cursor = clang_getTranslationUnitCursor(unit);
    clang_visitChildren(cursor, macroVisitor, nullptr);
    std::ranges::sort(gMacros);
    println("/* This file is auto-generated by tooling/SerializationCodegen.cpp */");
    println("#pragma once");
    println("");
    println("namespace {} {{", gNamespaceName);
    clang_visitChildren(cursor, structVisitor, nullptr);
    println("}}");

    clang_disposeTranslationUnit(unit);
    clang_disposeIndex(index);
    return 0;
}
